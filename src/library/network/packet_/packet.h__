#pragma once

#include "./packet_header.h"

#include <library/glimpse.h>
#include <include/endian.h>
#include <library/system.h>

#include <cstdint>
#include <memory>
#include <functional>
#include <atomic>
#include <span>


namespace maniscalco::network
{

    class efvi_dma_buffer;

    class packet
    {
    public:

        using size_type = std::uint16_t;
        using element_type = std::uint8_t;
        using iterator = element_type *;
        using const_iterator = element_type const *;
        using timestamp_type = packet_header::timestamp_type;

        packet() = default;

        packet
        (
            efvi_dma_buffer *,
            size_type, 
            size_type,
            timestamp_type
        );

        packet(size_type);

        packet(packet &&);

        packet & operator = (packet &&);

        packet(packet const &) = delete;
        packet & operator = (packet const &) = delete;

        ~packet();

        size_type capacity() const;

        operator bool() const;

        bool empty() const;

        iterator begin() const;

        iterator end() const;

        timestamp_type get_timestamp() const;

        std::int32_t get_error_code() const;
        
        packet_header & get_header();

        packet_header const & get_header() const;

        std::chrono::nanoseconds get_age() const;

        size_type get_size() const;

        element_type const * data() const;

        virtual_network_interface_id get_virtual_network_interface_id() const;

        std::uint64_t get_id() const;

        bool resize
        (
            size_type
        );

        operator std::span<element_type const>() const;

        operator std::span<element_type>() const;

        size_type dump
        (
            size_type
        );

    private:

        void release();

        element_type * data_{nullptr};

        static std::atomic<std::size_t> nextUniqueId_;

        struct pooled_buffer
        {
            std::uint8_t value_[2048];
        };
        static_assert(sizeof(pooled_buffer) == 2048);

    }; // class packet

} // namespace maniscalco::network


#include <library/network/efvi/efvi_dma_buffer.h>


//=============================================================================
inline maniscalco::network::packet::packet
(
    packet && other
):
    data_(std::exchange(other.data_, nullptr))
{
}


//=============================================================================
inline maniscalco::network::packet::packet
(
    size_type capacity
)
{
    auto size = (capacity + sizeof(packet_header) + 64);
    auto allocationType = packet_header::type::heap_allocation;

    if (size < 2048)
    {
        data_ = system::allocate<pooled_buffer>()->value_;
        allocationType = packet_header::type::pooled_allocation;
    }
    else
    {
        data_ = new std::uint8_t[capacity + sizeof(packet_header) + 64];
    }

    get_header() =
        {
            .type_ = allocationType,
            .headerSize_ = sizeof(packet_header),
            .beginOffset_ = 0,
            .size_ = 0,
            .timestamp_ = {},
            .errorCode_ = 0,
            .capacity_ = capacity,
            .id_ = nextUniqueId_++
        };
}


//=============================================================================
inline maniscalco::network::packet::packet
(
    // seat over memory provided
    // optional deleter hook
    efvi_dma_buffer * efviDmaBuffer,
    size_type beginOffset,
    size_type size,
    timestamp_type timestamp
):
    data_(reinterpret_cast<std::uint8_t *>(efviDmaBuffer))
{
    get_header().beginOffset_ = beginOffset;
    get_header().size_ = size;
    get_header().timestamp_ = timestamp;
    get_header().headerSize_ = efviDmaBuffer->get_data_offset();
    get_header().id_ = nextUniqueId_++;
}


//=============================================================================
inline maniscalco::network::packet::~packet
(
)
{
    release();
}


//=============================================================================
inline void maniscalco::network::packet::release
(
)
{
    if (data_ != nullptr)
    {
        switch (get_header().type_)
        {
            case packet_header::type::pooled_allocation:
            {
                system::deallocate<pooled_buffer>(reinterpret_cast<pooled_buffer *>(data_));
                break;
            }
            case packet_header::type::heap_allocation:
            {
                delete [] data_;
                break;
            }
            case packet_header::type::efvi_dma_buffer:
            {
                reinterpret_cast<efvi_dma_buffer *>(data_)->recycle();
                break;
            }
            default:
            {
                glimpse_error << "packet has undefined allocation type";
                delete [] data_;
                break;
            }
        }
        data_ = nullptr;
    }
}


//=============================================================================
inline auto maniscalco::network::packet::operator = 
(
    packet && other
) -> packet & 
{
    if (this != &other)
    {
        release();
        data_ = other.data_;
        other.data_ = nullptr;
    }
    return *this;
}


//=============================================================================
inline maniscalco::network::packet::operator bool
(
) const
{
    return (data_ != nullptr);
}


//=============================================================================
inline bool maniscalco::network::packet::empty
(
) const
{
    return (get_header().size_ == 0);
}


//=============================================================================
inline auto maniscalco::network::packet::dump
(
    // removes the first N bytes of data from the packet
    size_type bytesToDump
) -> size_type
{
    auto & header = get_header();
    auto bytesAvailable = header.size_;
    if (bytesAvailable < bytesToDump)
        bytesToDump = bytesAvailable;
    header.beginOffset_ += bytesToDump;
    header.size_ -= bytesToDump;
    return bytesToDump;  
}


//=============================================================================
inline auto maniscalco::network::packet::begin
(
) const -> iterator
{
    auto const & header = get_header();
    return (data_ + header.headerSize_ + header.beginOffset_);
}


//=============================================================================
inline auto maniscalco::network::packet::end
(
) const -> iterator
{
    auto const & header = get_header();
    return (begin() + header.size_);
}


//=============================================================================
inline auto maniscalco::network::packet::data
(
    // note: 'data' is not the beginning of the contents of the packet.
    // if you want the actual data stored within the usable part of the packet
    // then use `begin()` and `end()`.
    // `data()` returns the address of the meta data preamble (the header) which is stored
    // at the beginning of the underlying allocation upon which the packet is seated.
) const -> element_type const *
{
    return data_;
}


//=============================================================================
inline bool maniscalco::network::packet::resize
(
    size_type desiredSize
)
{
    if (desiredSize > capacity())
        return false; // nope!
    get_header().size_ = desiredSize;
    return true;
}


//=============================================================================
inline auto maniscalco::network::packet::get_size
(
) const -> size_type
{
    return get_header().size_;
}


//=============================================================================
inline maniscalco::network::packet::operator std::span<element_type const>
(
) const
{
    return std::span(begin(), get_size());
}


//=============================================================================
inline maniscalco::network::packet::operator std::span<element_type>
(
) const
{
    return std::span(begin(), get_size());
}